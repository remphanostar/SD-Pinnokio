---
description:
globs:
alwaysApply: true
---
# PinokioCloud Development Rules - Comprehensive Revision

## Project Overview
PinokioCloud is a cloud-native Pinokio alternative for multi-cloud GPU environments (Google Colab, Vast.ai, Lightning.ai, Paperspace, RunPod) with Streamlit UI. The goal is to implement complete Pinokio functionality as specified in Pinokio.md with zero deviations, creating a production-ready system that rivals desktop Pinokio in capabilities while leveraging cloud advantages.

## Cardinal Development Principles

### 0. MCP Tools Usage
**CRITICAL**: Any MCP tool available and visible to you is permitted to be used when ever nad however needed without permission. Memory Knowledgegraph and sequntial thinking are required to be used frequently and DDG and exa can be used when stuck:



### 1. Absolute Zero Placeholder Rule
**CRITICAL**: Every single line of code must be production-ready and fully functional. This is the cardinal sin prevention rule:
- Never create placeholder functions, mock implementations, or incomplete logic
- Never assume functionality will be completed later
- Never skip implementation details or create temporary workarounds
- Never continue development under false pretenses of completeness
- When uncertain about implementation details, STOP and prompt for guidance
- Every function, class, and method must be complete and tested before moving forward

### 2. Pinokio.md Sacred Compliance
- Follow Pinokio.md specifications with religious precision - no deviations permitted
- Implement ALL Pinokio API methods exactly as documented: shell.run, fs.download, fs.copy, fs.move, fs.link, fs.write, fs.read, fs.exists, fs.rm, script.start, script.stop, script.status, input, json.get, json.set, json.merge
- Support complete variable substitution system with all memory variables: platform, gpu, args, local, env, cwd, port, self, random, timestamp
- Honor daemon flag behavior precisely as specified
- Implement error handling patterns exactly as documented in Pinokio.md

### 3. Multi-Cloud Architecture Requirements
**Phase 1 Priority**: Cloud environment detection must be the foundation of everything
- Implement comprehensive detection for Google Colab, Vast.ai, Lightning.ai, Paperspace, RunPod, and local development environments
- Create adaptive path mapping systems for each platform's filesystem structure
- Build platform-specific optimization profiles with automatic adaptation
- Support environment-specific features like Google Drive mounting, Vast.ai certificate management, Lightning.ai team workspaces
- Never assume single-platform deployment

## File Structure and Architecture Standards

### Repository Structure (From Master Dev Plan)
```
cloud-pinokio/ (GitHub repository)
├── launcher.ipynb                    # Multi-cloud launcher (minimal cells, clean)
├── requirements.txt                  # Core dependencies
├── setup/                           # Cloud-specific setup scripts
├── app/                            # Main Streamlit application
│   ├── app.py                      # Enhanced Streamlit UI
│   ├── core/                       # Core engine modules
│   │   ├── pinokio_engine.py       # Complete Pinokio API emulation
│   │   ├── process_manager.py      # Advanced process management
│   │   ├── tunnel_manager.py       # Multi-tunnel orchestration
│   │   ├── environment_manager.py  # Virtual environment handling
│   │   └── storage_manager.py      # Intelligent storage system
│   ├── components/                 # Advanced UI components
│   ├── utils/                      # Utility modules
│   └── assets/                     # UI assets and themes
├── data/                           # Application data
├── docs/                           # Documentation
├── changelog.md                    # Mandatory change tracking
└── ai_handover_context/            # AI agent handover documentation
```

### Notebook Architecture Rules
- **Cell 1**: Repository cloning (MANDATORY) - clone main branch only, no other branches permitted
- **Cell 2-6**: Following the advanced launcher system from master dev plan
- Maximum 90% of scripts in repository, minimum notebook complexity
- Notebook must remain clean and functional throughout development
- Store ngrok token directly in notebook for convenience (personal project exception)

### Branch Management
- **MANDATORY**: All development occurs on main branch
- No feature branches, no development branches, no experimental branches
- All commits directly to main branch with descriptive messages
- Continuous integration approach with working main branch at all times

## Eight-Phase Development Structure (Reorganized Priority Order)

### Phase 1: Multi-Cloud Foundation and Detection (Days 1-5)
**Priority**: Cloud environment detection and adaptation BEFORE any other development
- Intelligent cloud detection system for all supported platforms
- Environment-specific path mapping and configuration
- Resource assessment frameworks (GPU, storage, network, security)
- Platform-specific optimization profiles
- Foundation architecture setup with proper abstractions

### Phase 2: Complete Pinokio Engine Implementation (Days 6-12)
**Priority**: Engine must be 100% complete before any UI development
- Complete shell.run with all subprocess management, signal handling, virtual environments
- Complete fs operations with atomic operations, checksums, rollback capabilities
- Complete script management with daemon handling, PID tracking, health monitoring
- Complete variable substitution with all memory variables and complex expressions
- Complete json operations with JSONPath support and atomic updates
- Complete input method with form handling and validation

### Phase 3: Advanced Application Lifecycle Management (Days 13-18)
- Intelligent installation system with pre-analysis and verification
- Virtual environment isolation exactly matching desktop Pinokio behavior
- Dependency resolution with conflict detection and resolution
- State management with SQLite database and recovery mechanisms
- Virtual drive system with deduplication and symbolic linking

### Phase 4: Web UI Discovery and Multi-Tunnel Management (Days 19-23)
- Comprehensive server detection for 15+ web frameworks
- Multi-provider tunnel orchestration (ngrok, Cloudflare, LocalTunnel)
- Gradio integration with automatic share parameter injection
- Advanced URL sharing with QR codes, analytics, and temporary links
- Health monitoring and automatic reconnection systems

### Phase 5: Cloud Platform Specialization (Days 24-26)
- Google Colab optimizations (Drive mounting, session management, GPU handling)
- Vast.ai professional features (certificates, Docker adaptation, billing optimization)
- Lightning.ai team integration (workspaces, collaboration, resource sharing)
- Cross-platform compatibility and performance optimization

### Phase 6: Advanced Features and Optimization (Days 27-28)
- Multi-layer caching system with intelligent prefetching
- Performance monitoring and resource optimization
- Error recovery and self-healing capabilities
- Advanced logging and analytics systems

### Phase 7: Comprehensive Testing and Validation (Days 29-30)
- Real-world application testing across all categories (video, text, image, audio)
- Multi-cloud testing matrix with different instance types
- Performance benchmarking and optimization
- Error condition testing and recovery validation

### Phase 8: Streamlit UI Polish and Production Readiness (Day 31)
**Final Phase**: UI polishing only after engine is 100% complete
- Dark cyberpunk theme refinement
- WebSocket integration for real-time updates
- Advanced terminal streaming with ANSI support
- Responsive design and mobile optimization
- User experience enhancements and accessibility

## Engine-First Development Mandate

### Engine Completion Requirements
- Pinokio engine must be 100% feature-complete before any significant UI development
- All API methods must be implemented, tested, and verified with real applications
- Process management, virtual environments, and daemon handling must be bulletproof
- Variable substitution system must handle all edge cases and complex expressions
- File operations must be atomic, safe, and recoverable

### Streamlit UI Development Rules
- Maintain basic functionality during engine development for testing purposes
- Major UI enhancements reserved for Phase 8 only
- Real-time feedback systems integrated throughout development for engine testing
- WebSocket integration for live process monitoring and terminal streaming
- Mobile-responsive design with QR code access for cloud environments

## Testing and Validation Standards

### AI Agent Self-Testing Requirements
- AI agent must install testing dependencies in its VM environment
- Implement notebook execution capability (nbconvert or similar tools)
- Create internal sandbox environment for testing Pinokio applications
- Generate actual ngrok/Gradio tunnels for real applications during testing
- Test with actual applications from cleaned_pinokio_apps.json database

### Real-World Application Validation Mandate
**CRITICAL**: Must successfully deploy and access web UIs for applications in each category:
- **Audio Processing**: Deploy RVC-realtime or VibeVoice-Pinokio with working web interface
- **Image Generation**: Deploy AUTOMATIC1111 or ComfyUI with accessible tunnel
- **Video Generation**: Deploy moore-animateanyone with functional web UI  
- **Text Generation**: Deploy text-generation-webui with working Gradio interface
- **ONLY** use scripts and files created for the project - no artificial workarounds
- Success measured by generating actual public tunnel URLs for each application type

### Testing Infrastructure Setup
- Install Jupyter notebook execution tools in AI agent VM
- Set up dependency management for testing environments  
- Implement tunnel testing and verification systems
- Create automated testing pipelines for continuous validation
- Build error reporting and debugging capabilities

## Pre-Phase Documentation Analysis and Conflict Resolution

### Mandatory Pre-Phase Analysis Protocol
**CRITICAL**: Before beginning any development phase, execute comprehensive documentation analysis:
- Ingest and analyze ALL relevant guides, development plans, and reference materials for the upcoming phase
- Cross-reference phase-specific documentation against master development plan strategic directives
- Identify direct contradictions, subtle misalignments, and areas of implementation uncertainty
- Generate comprehensive conflict classification with priority levels (Strategic/Implementation/Tactical)
- Create detailed clarification questions for ambiguous guidance or incomplete specifications
- Compile structured decision list with authority distribution recommendations

### Conflict Classification System
**Strategic Conflicts (Highest Priority)**: Require direct user input
- Multi-cloud compatibility requirements and platform support decisions
- Pinokio API compliance interpretations affecting core functionality
- Fundamental system architecture choices and integration approaches
- User interface paradigms and experience design principles
- Feature scope decisions that impact system capabilities

**Implementation Conflicts (Medium Priority)**: Can be user-decided or delegated with clear criteria
- Specific technical approaches and algorithm selection methods
- Performance optimization strategies and resource management techniques
- Error handling patterns and recovery mechanism designs
- Testing methodologies and validation approach selections
- Integration patterns with existing system components

**Tactical Conflicts (Lower Priority)**: Typically delegated to AI agent
- Code organization patterns and module structure decisions
- Documentation formatting standards and content organization
- Development workflow procedures and tool configuration choices
- Logging formats and debugging information capture methods
- File naming conventions and directory structure preferences

### Pre-Phase Decision Authority Framework
**User Authority Required**: Strategic architectural decisions, platform priority selections, fundamental feature scope choices, user experience paradigm selections, security and privacy policy decisions
**Delegated Authority Permitted**: Implementation technique selections with clear evaluation criteria, optimization approach choices within performance constraints, testing procedure selections meeting quality standards, tactical workflow decisions maintaining development efficiency
**Documentation Requirements**: Every conflict resolution must include source references, impact assessment, decision rationale, implementation guidance, monitoring criteria

### Comprehensive Question Generation Process
Beyond direct conflicts, systematic analysis must generate clarifying questions covering:
- Technical implementation details requiring additional specification
- User experience considerations needing design direction
- Performance optimization approaches requiring priority guidance  
- Integration requirements with existing system components
- Quality standards and acceptance criteria definitions
- Resource allocation and development timeline considerations

### Documentation and Change Management

#### Pre-Phase Conflict Analysis Documentation
- **MANDATORY**: Complete pre-phase analysis before any development work begins
- Document all identified conflicts with source references and impact assessments
- Generate comprehensive decision list with recommended authority distribution
- Create phase-specific guidance integration plan based on conflict resolutions
- Establish monitoring criteria for adherence to resolved conflicts during development

#### Changelog Management (changelog.md)
- **MANDATORY**: Update after every 5 functions created or edited
- Document all changes with timestamps, rationale, and impact assessment
- Include before/after comparisons for significant modifications
- Track performance improvements and feature additions
- Note any deviations from original plan with justification
- Record all pre-phase conflict resolutions and their implementation impact

#### AI Handover Context System (ai_handover_context/)
Create comprehensive handover documentation including:
- **project_overview.md**: Complete project description, goals, and current status
- **file_purpose_guide.md**: Every file's purpose and key functions documented
- **function_inventory.md**: Every function's purpose, parameters, and dependencies
- **development_roadmap.md**: Current phase, next steps, and completion plan
- **problem_log.md**: Last 5 problems encountered with solutions and lessons learned
- **conflict_resolution_history.md**: All pre-phase conflicts and their resolutions with decision rationale
- **guide_usage_instructions.md**: How to use all guides and development plans
- **testing_procedures.md**: How to test and validate implementations
- **deployment_instructions.md**: How to deploy and run the system

### Documentation Synchronization and Monitoring
- **MANDATORY**: Execute pre-phase documentation analysis before each development phase
- Review and integrate conflict resolutions into phase execution planning
- Monitor adherence to resolved conflicts throughout phase implementation
- Update AI handover context documentation with conflict resolution outcomes
- Track decision effectiveness and refine conflict analysis methodology
- Maintain comprehensive record of all architectural and implementation decisions

## Quality Assurance and Code Standards

### Code Quality Requirements
- Type hints mandatory for all function parameters and return values
- Comprehensive docstrings with usage examples and parameter descriptions
- Structured logging with appropriate levels (DEBUG, INFO, WARN, ERROR)
- Exception handling with specific error types and user-friendly messages
- Edge case handling for network issues, permission errors, missing files
- Performance optimization for cloud environment constraints

### Colab and Multi-Cloud Compatibility
- Environment detection using sys.modules and filesystem analysis
- Adaptive path handling for different cloud platforms
- Resource limit awareness and optimization
- Network restriction handling and tunnel management
- Session management and recovery capabilities
- Storage optimization for ephemeral and persistent environments

### Production Readiness Standards
- No hardcoded values or environment-specific assumptions
- Graceful degradation for missing features or limited environments
- Comprehensive error messages with actionable guidance
- Resource cleanup and proper shutdown procedures
- Security considerations for shared cloud environments
- Performance monitoring and optimization capabilities

## Forbidden Actions (Updated)

### Absolute Prohibitions
- **NEVER** create placeholder functions or incomplete implementations
- **NEVER** skip error handling or assume "it will work"
- **NEVER** create branches other than main for development
- **NEVER** assume single-platform deployment (must support all target clouds)
- **NEVER** break backward compatibility with existing Pinokio applications
- **NEVER** deviate from Pinokio.md specifications without explicit justification

### Flexible Guidelines
- Notebook structure can be enhanced if 90% of logic remains in repository
- GitHub workflow can be optimized for resume capability and LFS support
- File operations can be enhanced beyond basic requirements for robustness
- UI components can be restructured for better user experience
- Testing procedures can be expanded for comprehensive validation

## Development Execution Standards

### Problem-Solving Protocol
- When uncertain about implementation details: STOP and request guidance
- When encountering contradictory requirements: STOP and seek clarification  
- When facing technical limitations: STOP and discuss alternatives
- Never proceed with assumptions that could compromise system integrity
- Document all decisions and rationale in changelog and handover context

### Todo List Management
- Todo lists can be expanded and enhanced throughout development
- **NEVER** remove items from existing todo lists without completion
- Add implementation details and sub-tasks as understanding improves
- Mark completed items with timestamps and brief completion notes
- Maintain todo lists as living documents that guide development

This comprehensive revision ensures your PinokioCloud development follows the highest standards while maintaining absolute fidelity to Pinokio specifications and creating a truly production-ready cloud-native AI application platform.